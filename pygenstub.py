# Copyright (c) 2016-2017 H. Turgut Uyar <uyar@tekir.org>
#
# pygenstub is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pygenstub is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pygenstub.  If not, see <http://www.gnu.org/licenses/>.

from typing import Mapping, Optional

from argparse import ArgumentParser
from collections import OrderedDict, namedtuple
from docutils.core import publish_doctree
from docutils.nodes import document
from io import StringIO

import ast
import logging
import sys


_logger = logging.getLogger(__name__)


EDIT_WARNING = 'THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT MANUALLY.'
BUILTIN_TYPES = {'int', 'float', 'str', 'bool',
                 'dict', 'list', 'tuple', 'set', 'None'}

Signature = namedtuple('Signature', ['content', 'requires'])


def get_fields(node: document) -> Mapping[str, str]:
    """Get all field names and values from a node.

    :param node: Node to get the fields from.
    :return: Field names and their values.
    """
    nodes = [c for c in node.children if c.tagname == 'field_list']
    if not nodes:
        return {}
    assert len(nodes) == 1
    node = nodes[0]
    fields = [{f.tagname[6:]: f.rawsource.strip() for f in n.children}
              for n in node.children if n.tagname == 'field']
    return {f['name']: f['body'] for f in fields}


def get_signature(node: ast.FunctionDef) -> Optional[Signature]:
    """Get the signature for a function.

    :param node: Function node to get the signature for.
    :return: Signature content and required type names.
    """
    docstring = ast.get_docstring(node)
    if docstring:
        doctree = publish_doctree(docstring)
        fields = get_fields(doctree)
        signature = fields.get('signature')
        if signature:
            _logger.debug('parsing signature for %s', node.name)
            lhs, rtype = [s.strip() for s in signature.split(' -> ')]
            pstr = lhs[1:-1].strip()    # remove the () from parameters
            ptypes = [p.strip() for p in pstr.split(',')] if pstr != '' else []
            _logger.debug('parameter types: %s', ptypes)
            _logger.debug('return type: %s', rtype)

            params = [arg.arg for arg in node.args.args]
            assert len(ptypes) == len(params)
            pstub = ', '.join([('%s: %s' % p) for p in zip(params, ptypes)])
            content = 'def %s(%s) -> %s: ...\n' % (node.name, pstub, rtype)
            requires = [n for n in ptypes + [rtype] if n not in BUILTIN_TYPES]
            _logger.debug('requires %s', requires)
            _logger.debug('signature: %s', content)
            return Signature(content, requires)
    return None


def get_stub(code: str) -> str:
    """Get the stub declarations for a source code.

    :param code: Source code to generate the stub for.
    :return: Stub declarations for the source code.
    """
    stub = StringIO()
    tree = ast.parse(code)

    imported_names = OrderedDict([(name.name, node.module)
                                  for node in tree.body
                                  if isinstance(node, ast.ImportFrom)
                                  for name in node.names])
    _logger.debug('imported names: %s', imported_names)

    signatures = OrderedDict(filter(lambda x: x[1] is not None,
                                    [(node.name, get_signature(node))
                                     for node in tree.body
                                     if isinstance(node, ast.FunctionDef)]))

    if len(signatures) > 0:
        required_names = {r for s in signatures.values() for r in s.requires}
        if len(required_names) > 0:
            unknown_names = required_names - set(imported_names.keys())

            typing_module = __import__('typing')
            typing_names = [n for n in unknown_names
                            if hasattr(typing_module, n)]
            _logger.debug('names from typing module: %s', typing_names)

            missing_names = unknown_names - set(typing_names)
            if len(missing_names) > 0:
                print('Following names could not be found: %s' % (', '.join(missing_names)),
                      file=sys.stderr)
                sys.exit(1)

            if typing_names:
                stub.write('from typing import %s\n' % (', '.join(typing_names),))

            for name, module in imported_names.items():
                if name in required_names:
                    stub.write('from %s import %s\n' % (module, name))
            stub.write('\n\n')
        stub.write('\n\n'.join([s.content for s in signatures.values()]))
    return stub.getvalue()


def main() -> None:
    """Entry point of the command-line utility."""
    parser = ArgumentParser()
    parser.add_argument('source', help='source file to generate the stub for')
    parser.add_argument('--debug', action='store_true', help='enable debug messages')
    arguments = parser.parse_args()

    log_level = logging.DEBUG if arguments.debug else logging.INFO
    logging.basicConfig(level=log_level)

    with open(arguments.source, mode='r') as f_in:
        code = f_in.read()

    stub = get_stub(code)

    destination = arguments.source + 'i'
    if len(stub) > 0:
        with open(destination, mode='w') as f_out:
            f_out.write('# %s\n\n\n' % (EDIT_WARNING,))
            f_out.write(stub)


if __name__ == '__main__':
    main()
