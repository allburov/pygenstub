# Copyright (c) 2016-2017 H. Turgut Uyar <uyar@tekir.org>
#
# pygenstub is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pygenstub is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pygenstub.  If not, see <http://www.gnu.org/licenses/>.

from argparse import ArgumentParser
from docutils.core import publish_doctree
from io import StringIO

import ast


TYPING_NAMES = {'Any', 'Dict', 'Optional'}


def get_fields(node, container='field_list'):
    nodes = [c for c in node.children if c.tagname == container]
    if not nodes:
        return {}
    assert len(nodes) == 1
    node = nodes[0]
    fields = [{f.tagname[6:]: f.rawsource.strip() for f in n.children}
              for n in node.children if n.tagname == 'field']
    return {f['name']: f['body'] for f in fields}


def get_signatures(tree):
    signatures = {}
    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            docstring = ast.get_docstring(node)
            if docstring:
                doctree = publish_doctree(docstring)
                fields = get_fields(doctree)
                signature = fields.get('signature')
                if signature:
                    params = [arg.arg for arg in node.args.args]
                    signatures[node.name] = (signature, params)
    return signatures


def get_stub_data(signatures, imported_names):
    prototypes = []
    typing_lines = []
    import_lines = []
    for func, (sign, params) in sorted(signatures.items()):
        lhs, rtype = sign.split(' -> ')
        param_str = lhs[lhs.find('(')+1:lhs.rfind(')')]
        param_types = [s.strip() for s in param_str.split(',') if s.strip()]
        for t in TYPING_NAMES:
            if rtype.startswith(t):
                typing_line = 'from typing import %s\n' % (t,)
                typing_lines.append(typing_line)
        if rtype in imported_names:
            import_line = 'from %s import %s\n' % (imported_names[rtype], rtype)
            import_lines.append(import_line)
        params_stub = ', '.join([('%s: %s' % p) for p in zip(params, param_types)])
        signature = 'def %s(%s) -> %s: ...\n' % (func, params_stub, rtype)
        prototypes.append(signature)
    return prototypes, typing_lines + [''] + import_lines


def get_stub(code: str) -> str:
    """Get the stub declarations for a source code.

    :param code: Source code to generate the stub for.
    :return: Stub declarations for the source code.
    """
    stub = StringIO()
    tree = ast.parse(code)

    imported_names = {name.name: node.module
                      for node in tree.body
                      if isinstance(node, ast.ImportFrom)
                      for name in node.names}
    signatures = get_signatures(tree)

    prototypes, import_lines = get_stub_data(signatures, imported_names)
    if prototypes:
        if import_lines:
            stub.write('\n'.join(import_lines) + '\n')
        stub.write('\n'.join(prototypes))
    return stub.getvalue()


def main() -> None:
    """Entry point of the command-line utility."""
    parser = ArgumentParser()
    parser.add_argument('source', help='source file to generate the stub for')
    arguments = parser.parse_args()

    with open(arguments.source, mode='r') as f_in:
        code = f_in.read()

    stub = get_stub(code)

    destination = arguments.source + 'i'
    with open(destination, mode='w') as f_out:
        f_out.write('# THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT.\n')
        f_out.write(stub)


if __name__ == '__main__':
    main()
