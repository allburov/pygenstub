# Copyright (c) 2016-2017 H. Turgut Uyar <uyar@tekir.org>
#
# pygenstub is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pygenstub is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pygenstub.  If not, see <http://www.gnu.org/licenses/>.

from typing import Mapping, Optional

from argparse import ArgumentParser
from collections import OrderedDict, namedtuple
from docutils.core import publish_doctree
from docutils.nodes import document
from io import StringIO

import ast
import logging


_logger = logging.getLogger(__name__)


EDIT_WARNING = 'THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT MANUALLY.'

TYPING_NAMES = {'Any', 'Dict', 'Optional'}


Signature = namedtuple('Signature', ['content', 'requires'])


def get_fields(node: document) -> Mapping[str, str]:
    """Get all field names and values from a node.

    :param node: Node to get the fields from.
    :return: Field names and their values.
    """
    nodes = [c for c in node.children if c.tagname == 'field_list']
    if not nodes:
        return {}
    assert len(nodes) == 1
    node = nodes[0]
    fields = [{f.tagname[6:]: f.rawsource.strip() for f in n.children}
              for n in node.children if n.tagname == 'field']
    return {f['name']: f['body'] for f in fields}


def get_signature(node: ast.FunctionDef,
                  imports: Mapping[str, str]) -> Optional[Signature]:
    """Get the signature for a function.

    :param node: Function node to get the signature for.
    :param imports: Imported names that might be required for the signature.
    :return: Signature content and required imported names.
    """
    docstring = ast.get_docstring(node)
    if docstring:
        doctree = publish_doctree(docstring)
        fields = get_fields(doctree)
        signature = fields.get('signature')
        if signature:
            _logger.debug('parsing signature for %s', node.name)
            lhs, rtype = [s.strip() for s in signature.split(' -> ')]
            pstr = lhs[1:-1].strip()    # remove the () from parameters
            ptypes = [p.strip() for p in pstr.split(',')] if pstr != '' else []
            _logger.debug('parameter types: %s', ptypes)
            _logger.debug('return type: %s', rtype)

            params = [arg.arg for arg in node.args.args]
            assert len(ptypes) == len(params)
            pstub = ', '.join([('%s: %s' % p) for p in zip(params, ptypes)])
            content = 'def %s(%s) -> %s: ...\n' % (node.name, pstub, rtype)
            requires = [n for n in ptypes + [rtype] if n in imports]
            _logger.debug('requires %s', ', '.join(requires))
            _logger.debug('signature: %s', content)
            return Signature(content, requires)
    return None


def get_stub(code: str) -> str:
    """Get the stub declarations for a source code.

    :param code: Source code to generate the stub for.
    :return: Stub declarations for the source code.
    """
    stub = StringIO()
    tree = ast.parse(code)

    imports = OrderedDict([(name.name, node.module)
                           for node in tree.body
                           if isinstance(node, ast.ImportFrom)
                           for name in node.names])
    _logger.debug('imported names: %s', ', '.join([v + '.' + k for k, v in imports.items()]))

    signatures = OrderedDict(filter(lambda x: x[1] is not None,
                                    [(node.name, get_signature(node, imports))
                                     for node in tree.body
                                     if isinstance(node, ast.FunctionDef)]))

    if len(signatures) > 0:
        required = {r for s in signatures.values() for r in s.requires}
        if len(required) > 0:
            for name, module in imports.items():
                if name in required:
                    stub.write('from %s import %s\n' % (module, name))
            stub.write('\n\n')
        stub.write('\n\n'.join([s.content for s in signatures.values()]))
    return stub.getvalue()


def main() -> None:
    """Entry point of the command-line utility."""
    parser = ArgumentParser()
    parser.add_argument('source', help='source file to generate the stub for')
    parser.add_argument('--debug', action='store_true', help='enable debug messages')
    arguments = parser.parse_args()

    log_level = logging.DEBUG if arguments.debug else logging.INFO
    logging.basicConfig(level=log_level)

    with open(arguments.source, mode='r') as f_in:
        code = f_in.read()

    stub = get_stub(code)

    destination = arguments.source + 'i'
    if len(stub) > 0:
        with open(destination, mode='w') as f_out:
            f_out.write('# %s\n\n\n' % (EDIT_WARNING,))
            f_out.write(stub)


if __name__ == '__main__':
    main()
